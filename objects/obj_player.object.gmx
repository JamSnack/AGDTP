<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_playerWalk</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>PAUSE</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize the player
state = IDLE;
hsp = 0; //current horizontal speed
vsp = 0; //current vertical speed
tool = 0; //The player holds nothing.
tool_buffer = noone; //The last tool the player held before switching to building mode
knockBack = false;
knockPoint_x = 0;
knockPoint_y = 0;
climbSpeed = 2;
platformCollide = true;
deactivate_method = 0;

image_speed = 10/60;
mask_index = spr_playerIdle;
armIndex = spr_armIdle;
armFrame = 0;
armAngle = 0;
armAngleGoal = 0;
armAngleRate = 0;
armOffset = 0; //Used for thrusting the arm forward or backward!
armOffsetGoal = 0;
armOffsetRate = 0;
armStabComplete = false;
toolAnimation = "SWING";
knockType = "LAND";
hForce = 0;
vForce = 0;

//Initialize Player Stats
maxHp = 100; //Maximum health
hp = maxHp; //current health
canHurt = true; //The player can take damage.
hurtAlarm = 0; //The alarm to activate when hurt.
hsp_walk = 2; //Max walk speed
vsp_jump = -5; //Max jump speed
break_range = 2; //Tiles around the player that can be broken.
dead = false; //Whether or not the player is dead.
knock_resistance = 0.24;

//Tool variables
toolReady = true;
toolSprite = spr_sword;
toolFireRate = 40;
projSpeed = 3.5;
projDecay = 0.25;
projSprite = spr_projectile1;
weaponDamage = 4;
weaponKnockback = 3;
pickDamage = 1;
pickLevel = 0;
pickRange = 4;
g_over = false;
canUseTool = true;
hitSyncX = 0; //Hitbox Synchronizers
hitSyncY = 0;
playerLight = 0; //How bright light is underground.
tool_snd = noone;
shield_charges = 0;

//Tag Resets
globalvar bright_reset;
bright_reset = false; //Boolean to reset the light stat to 16. PROLLY NEEDS TO CHANGE IN THE FUTURE LOL

if room = rm_zero then g_over = gameOver;

friction = 0.3;

//Apply equipped accessories
scr_reloadAccessories();

//AUDIO
audio_listener_orientation(0,0,-1000,0,1,0);

//Tutorial tips
if tip_controls == false
{
    scr_createTip(1.5,1.75,"controls");
}

//SPAWN NOT INSIDE TILES
while place_meeting(x,y,PLRTILE) y-=16;

//scr_dropItem(ITEMID.weapon_weakBow,0,ITEMTYPE.weapon,x,y,noone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset animations &amp; tool ready
armIndex = spr_armIdle;
toolReady = true; 
armAngle = 0;
armOffset = 0;
armOffsetRate = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Respawn after death
g_over = gameOver;

if g_over == false
{
    visible = true;
    x = obj_pie.x;
    y = obj_pie.y-32;
    while place_meeting(x,y,OBSTA) y-=16;
    hp = maxHp;
    dead = false;
    hForce = 0;
    vForce = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset canHurt;
canHurt = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement and Death Check
if dead = false &amp;&amp; g_over == false
{
    var spr_height = sprite_get_height(spr_playerIdle)/2;
    var spr_width = sprite_get_width(spr_playerIdle)/2;

    if knockBack == false
    {
        key_right = keyboard_check(global.key_right);
        key_left = keyboard_check(global.key_left);
        key_jump = keyboard_check(global.key_jump);
        key_down = keyboard_check(global.key_down);
    }
    
    hsp = (key_right - key_left) * hsp_walk;
    if vsp &lt; maxGrav then vsp = vsp + grav;
    
    //Jump check
    if  key_jump &amp;&amp; ((collision_point(x-3,y+spr_height+1,OBSTA,false,true) || collision_point(x+2,y+spr_height+1,OBSTA,false,true)) || (collision_point(x,y+spr_height+1,obj_platform,true,true)))
    {
        vsp = vsp_jump;
    }
    
    //Horizontal Movement
    var hdir = sign(hsp+hForce) //Horizontal Direction
    
    if hdir != 0 then image_xscale = hdir;
    if (place_meeting_fast(hsp+hForce,0,OBSTA))
    {
        //move as close as we can
        while (!place_meeting_fast(hdir,0,OBSTA))
        { x = x + hdir; }
        hsp = 0;
        hForce = 0;
    }
    
    x = x+hsp+hForce;
    hForce = approach(hForce,0,knock_resistance);
    
    //Vertical Movement
    var hdir = sign(vsp+vForce); //up = -1, down = 1.
    
    //Ladder Logic
    if place_meeting_fast(0,0,obj_ladder)
    {
        //Stop falling
        if vsp != 0 { vsp = 0; }
        
        //-Climb the ladder
        if !place_meeting_fast(0,-climbSpeed,OBSTA) &amp;&amp; key_jump 
        {
            y-=climbSpeed;
        }
        else if !place_meeting_fast(0,climbSpeed,OBSTA) &amp;&amp; key_down 
        {
            y+=climbSpeed;
        }
        
        //Don't collide with platforms
        platformCollide = false;
    }
    
    
    //--Collision with ground; else platform
    if (vsp+vForce &gt;= 0 &amp;&amp; (position_meeting(x-3,y+spr_height+vsp+vForce+1,OBSTA) || position_meeting(x+3,y+spr_height+vsp+vForce+1,OBSTA))) || (vsp+vForce &lt; 0 &amp;&amp; (position_meeting(x-3,y-spr_height+vsp+vForce+1,OBSTA) || position_meeting(x+3,y-spr_height+vsp+vForce+1,OBSTA)))
    {
        //move as close as we can
        while (!place_meeting_fast(0,hdir,OBSTA))
        { y = y+hdir; }
        vsp = 0;
        vForce = 0;
    }
    //---------PLATFORM COLLISION
    else if !key_down &amp;&amp; instance_exists(obj_platform)
    {
        var _plat = instance_place(x,y+vsp+vForce,obj_platform);
                
        if _plat != noone &amp;&amp; vsp+vForce &gt; 0 &amp;&amp; y+spr_height &lt; _plat.y
        {
            while(!place_meeting_fast(0,sign(vsp+vForce),_plat))
            {
                y += sign(vsp+vForce);
            }
            
            if collision_point(0,spr_height+vsp+vForce,_plat,true,true)
            {
                //Check for cases w/ overlapping hitboxes
                while(place_meeting_fast(0,0,_plat))
                {
                    y -= 1;
                }
            }
            
            vForce = 0;
            vsp = 0;
        }
    }

    y = y+vsp+vForce;
    vForce = approach(vForce,0,knock_resistance);
    
    //Jump sprites
    if vsp != 0 &amp;&amp; !place_meeting_fast(0,1,OBSTA)
    {
        if sprite_index != spr_playerJump then sprite_index = spr_playerJump;
        if armIndex != spr_armJump &amp;&amp; armAngle == 0 then armIndex = spr_armJump;
        if y &gt; yprevious then image_index = 1 else image_index = 0;
        armFrame = image_index;
        platformCollide = false;
    }
    
    ///Knockback
    if knockBack == true
    {
        if hForce+vForce == 0 { knockBack = false; }
    }
    
    
    //------------------Sprites--------------------
    switch state
    {
        case IDLE:
        {
            if sprite_index != spr_playerIdle &amp;&amp; vsp == 0 then sprite_index = spr_playerIdle;
            if armIndex != spr_armIdle &amp;&amp; armAngle == 0 &amp;&amp; vsp == 0 then armIndex = spr_armIdle;
            if image_speed != 10/60 then image_speed = 10/60;
            
            if hsp != 0 then state = MOVE;
        }
        break;
    
        case MOVE:
        {
            if sprite_index != spr_playerWalk &amp;&amp; (position_meeting(x,y+1+spr_height,OBSTA) || position_meeting(x,y+1+spr_height,obj_platform) ) then sprite_index = spr_playerWalk;
            if armIndex != spr_armWalk &amp;&amp; armAngle == 0 &amp;&amp; vsp == 0 then armIndex = spr_armWalk;
            if image_speed != (14+((hsp_walk)/10))/60 then image_speed = (14+((hsp_walk)/10))/60;
            
            if hsp == 0 then state = IDLE;
        }
        break;
    }
    
    if armAngle == 0 { armFrame = image_index; } else armFrame = 0;
    
    //Animate Arm movement
    //- Swing
    if armAngle != 0 &amp;&amp; toolAnimation == "SWING" &amp;&amp; tool != 4
    {
        //Move the arm back to 0.
        if armAngle &gt; armAngleGoal
        { 
            armAngle = approach(armAngle,armAngleGoal,armAngleRate);
            
            //Do not let armAngle = 0, this will stop the animation.
            if armAngle == 0 then armAngle = 0.1;
            
            if armAngle &lt;= armAngleGoal 
            { 
                armIndex = spr_armIdle;
                toolReady = true; 
                armAngle = 0; 
            }
        }
        
    
    //---Stab--- 
       
    } 
    else if toolAnimation == "STAB" &amp;&amp; tool != 4
    {
        if armStabComplete == false
        {
            if armOffset &lt; armOffsetGoal 
            { armOffset += armOffsetRate }
            else
            { armStabComplete = true; }
        } 
        else
        {
            armOffset -= armOffsetRate;

            if armOffset &lt;= 0
            {
                //Reset to default values
                //- arm index doesn't need to reset.
                toolReady = true;
                armStabComplete = false;
                armOffset = 0;
                armOffsetRate = 0;
                armOffsetGoal = 0;
                hitSyncX = 0;
                hitSyncY = 0;
            }
        }
        //- cute little magic used for simulating 360 degrees of arm movement that isn't actually real ;-;
        var _dir = point_direction(x,y,mouse_x,mouse_y);
            
        //- prepare _dir for further processing...
        if image_xscale == -1 then _dir = (_dir-180)*-1;
        
        hitSyncY = y+lengthdir_y((armOffset),_dir);
        hitSyncX = x+lengthdir_x((armOffset)*image_xscale,_dir);
    }
    else if toolAnimation == "SHOOT" &amp;&amp; ( tool == 2 || tool == 1) &amp;&amp; toolReady == false
    {
        //Aim towards the mouse!
        var _dir = point_direction(x,y,mouse_x,mouse_y);
        image_xscale = sign(mouse_x-x);
        armIndex = spr_armSwing; //Still a straight arm.
        if image_xscale == 1 then armAngle = _dir else armAngle = (_dir-180)*-1;
    }
    
    //Face mouse when using item
    if mouse_check_button(mb_left) &amp;&amp; hudControl.cursorHoldItem == false
        { if mouse_x != x then image_xscale = sign(mouse_x-x); }
        
}
    
    
    
//---------check for death-----------
if dead == false
{
    if hp &lt;= 0 || g_over == true
    {
        dead = true;
        alarm[1] = room_speed*5;
        visible = false;
        
        //LOSE ESSENCE
        var essence_lost = ceil(scr_getInvenItemAmt(ITEMID.item_gremEssence)*0.10);
        
        scr_invenRemoveItem(ITEMID.item_gremEssence,essence_lost,0,false,-1,noone);
        scr_hudMessage(string(essence_lost)+" essence lost...",global.fnt_Ui,5,0,c_red,0);
        
        //Respawn at the pie
        x = obj_pie.x;
        y = obj_pie.y;
    }
    
//---AUDIO LISTENENR POSITION----
audio_listener_position(x,y,0);
}

//Remain inside the room at all times
x = clamp(x,0,room_width);
y = clamp(y,0,room_height);

//Arm calculations will sometimes cause image_xscale to be zero.
if image_xscale != 1 &amp;&amp; image_xscale &gt;= 0 then image_xscale = 1
else if image_xscale != -1 &amp;&amp; image_xscale &lt; 0 then image_xscale = -1;

//HP clamp
hp = clamp(hp,0,maxHp);

//print(region);

//Can hurt animation
if canHurt == false &amp;&amp; dead == false
{
    image_alpha = approach(image_alpha,0,0.1);
    
    if image_alpha = 0 then image_alpha = 1;
}
else if image_alpha != 1
{
    image_alpha = approach(image_alpha,1,0.1);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interact
//-------INTERACT KEY------------
if keyboard_check_released(global.key_interact)
{
    //Interact with objects that aren't crafting
    if instance_exists(INTERACT)
    {
        var interact = instance_nearest(x,y,INTERACT);
        
        if distance_to_point(interact.x,interact.y) &lt; 32 &amp;&amp; interact.bench == false
        {
            with interact event_user(0);
        }
    }
}

//-----QUICK HEAL KEY----------
if keyboard_check_released(global.key_quick_heal)
{
    if hp &lt; maxHp
    {
        //List of items to look for.
        var heal_list = array_create(1);
        heal_list[0] = ITEMID.cons_treeFruit;
        
        //Quickly heal by searching for the first healing item in the inventory and eating it!
        var loop_size = array_length_1d(heal_list);
        
        for(i=0;i&lt;loop_size;i++)
        {
            //Find the item's 
            var heal_slot = scr_findInvenItem(heal_list[i]);
            
            if heal_slot != noone
            {
                scr_useConsumable(hudControl.inventorySlotIcon[heal_slot]);
            }
            else if i == loop_size-1
            {
                audio_play_sound(snd_invalid,12,false);
            }
        }
    }
    else if hp &gt;= maxHp
    {
        audio_play_sound(snd_invalid,12,false);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then y += 5;

//x = obj_pie.x;
//y = obj_pie.y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then x += 5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then y -= 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then x -= 5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Use Tool
//Check for inventory use
if dead == false &amp;&amp; hudControl.settingsMenu == false &amp;&amp; hudControl.selectedSlot != noone &amp;&amp; hudControl.equipQueue == noone &amp;&amp; hudControl.showSuperMenu == false
{
    var dx = device_mouse_x_to_gui(0)
    var dy = device_mouse_y_to_gui(0)
    
    //Defines the crafting menu's dimensions.
    var _cmX = view_wview[0]/2-120;
    var _cmY = view_hview[0]/2-105;
    
    if 
        //- Inventory stipulations
        !point_in_rectangle(dx,dy,0,5,125,15) &amp;&amp; !point_in_rectangle(dx,dy,0,50,hudControl.invenX,70) 
        &amp;&amp; hudControl.cursorHoldItem == false &amp;&amp;
        
        //- Crafting Menu stipulations
        !(hudControl.showSuperMenu == true &amp;&amp; point_in_rectangle(dx,dy,_cmX,_cmY,250+_cmX,200+_cmY))
    {
        //- Variable declarations and rules
        var slot = hudControl.selectedSlot;
        if slot == noone then exit;
        
        var item = hudControl.inventorySlotIcon[slot];
        if item == 0 then exit;
        
        //-----SOUND------
        if tool_snd != noone &amp;&amp; toolReady == true &amp;&amp; (tool == 2 || tool == 1)
        {
            var snd = noone;
        
            switch tool_snd
            {
                case "SWISH": { snd = choose(snd_swish1,snd_swish2,snd_swish3,snd_swish4); } break;
            
                default: snd = tool_snd;
            }
        
            audio_play_sound(snd,10,false);
        }
        
        
        //-------USE THE TOOL !----------
        switch tool
        {
            case 1:
            {
                //Weapon slot
                if toolReady == true
                {
                    //Use weapon
                    scr_useWeapon(proj_type,projSpeed,projDecay,projSprite,weaponDamage,weaponKnockback);
                    
                    switch toolAnimation
                    {
                        case "SWING":
                        {
                            armIndex = spr_armSwing;
                            armAngleGoal = -60; //Down somewhat
                            armAngle = 90; //Straight up
                            armAngleRate = (180/toolFireRate)+1;
                            toolReady = false;
                        }
                        break;
                        
                        case "SHOOT":
                        {
                            var _dir = point_direction(x,y,mouse_x,mouse_y);
                            
                            image_xscale = sign(mouse_x-x);
                        
                            armIndex = spr_armSwing; //Still a straight arm.
                            if image_xscale = 1 then armAngle = _dir else armAngle = (_dir-180)*-1;
                            
                            toolReady = false;
                            alarm[2] = toolFireRate;
                        }
                        break;
                        
                        case "STAB":
                        {   
                            //Initialize Animation
                            var _dir = point_direction(x,y,mouse_x,mouse_y);
                            
                            image_xscale = sign(mouse_x-x);
                        
                            armIndex = spr_armSwing; //Still a straight arm.
                            if image_xscale = 1 then armAngle = _dir else armAngle = (_dir-180)*-1;
                            toolReady = false;
                            alarm[2] = toolFireRate;
                            
                            armOffset = 0;
                            armOffsetGoal = 20;
                            armOffsetRate = (armOffsetGoal*2)/toolFireRate;
                            armStabComplete = false;
                        }
                        break;
                    }
                }
            }
            break;
            
            case 2:
            {
                //Pickaxe Slot
                if toolReady == true
                {
                    scr_usePickaxe(pickDamage,pickLevel);
                    
                    switch toolAnimation
                    {
                        case "SWING":
                        {
                            armIndex = spr_armSwing;
                            armAngleGoal = -60; //Down somewhat
                            armAngle = 90; //Straight up
                            armAngleRate = (180/toolFireRate)+1; //180 is a number larger than the goal. This calculation will always result in an angle rate that is fast enough to finish the animation.
                        }
                        break;
                        
                        case "SHOOT":
                        {
                            //Aiming done in the step event.
                            armIndex = spr_armSwing; //Still a straight arm.
                            alarm[2] = toolFireRate;
                        }
                        break;
                    }
                    
                    toolReady = false;
                }
            }
            break;
            
            case 4:
            {
                //Consumable
                if toolReady == true &amp;&amp; room == rm_zero
                {
                    toolReady = false;
                    scr_useConsumable(hudControl.inventorySlotIcon[slot]);
                }
            }
            break;
            
            case ITEMTYPE.accessory:
            {
                if toolReady == true
                {
                    //Equip/Dequip the accessory
                    scr_applyAccessory(item);
                    
                    toolReady = false;
                    toolAnimation = "SWING";
                    armIndex = spr_armSwing;
                    armAngleGoal = 71;
                    armAngle = 70; //Straight up
                    armAngleRate = 0;
                    toolSprite = spr_nothing;
                    alarm[2] = room_speed/2;
                }
            }
            break;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw body
draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,0,c_white,image_alpha);

//draw arms
//- Draw tool
if toolReady == false 
{
    switch toolAnimation
    {
        case "SWING":
        {
            draw_sprite_ext(toolSprite,0,x+lengthdir_x(11*image_xscale,armAngle),y-lengthdir_y(-10,armAngle)-2,image_xscale,image_yscale,armAngle*image_xscale,c_white,1);
        } 
        break;
        
        case "SHOOT":
        {
            draw_sprite_ext(toolSprite,0,x+lengthdir_x(11*image_xscale,armAngle),y-lengthdir_y(-10,armAngle)-2,image_xscale,image_yscale,armAngle*image_xscale,c_white,1);
        }
        break;
        
        case "STAB":
        {
            if armOffset == 0 then break;
            //Click to deathpoke the Gremlins.
            //- cute little magic used for simulating 360 degrees of arm movement that isn't actually real ;-;
            var _dir = point_direction(x,y,mouse_x,mouse_y);
            
            //- prepare _dir for further processing...
            if image_xscale == -1 then _dir = (_dir-180)*-1;
            
            var yOffset = lengthdir_y((armOffset),_dir);
            var xOffset = lengthdir_x((armOffset)*image_xscale,_dir);
            
            draw_sprite_ext(toolSprite,0,x+xOffset,y+yOffset,image_xscale,image_yscale,_dir*image_xscale,c_white,1);
            //- STAB arm animator
            draw_sprite_ext(armIndex,armFrame,x,y,image_xscale,image_yscale,_dir*image_xscale,c_white,1);
        }
        break;
    }
}

//- Default arm animator
if armOffset == 0
{ draw_sprite_ext(armIndex,armFrame,x,y,image_xscale,image_yscale,armAngle*image_xscale,c_white,image_alpha); }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="100">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev != true then exit;
instance_create(x,y,region_shifter);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="99">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev != true then exit;
scr_dropItem(ITEMID.item_stonePiece,99,0,x,y,noone);
scr_dropItem(ITEMID.item_dirtClump,99,0,x,y,noone);
scr_dropItem(ITEMID.item_gremEssence,99,0,x,y,noone);
scr_dropItem(ITEMID.item_copperOre,99,0,x,y,noone);
scr_dropItem(ITEMID.item_seashellMetal,99,0,x,y,noone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="97">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev != true then exit;
//instance_create(mouse_x,mouse_y,obj_drillin);

if instance_exists(worldControl.raidBossID)
{
worldControl.raidBossID.x = -16;
worldControl.raidBossID.y = -16;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
