<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_playerWalk</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>PAUSE</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize the player
state = IDLE;
hsp = 0; //current horizontal speed
vsp = 0; //current vertical speed
tool = 0; //The player holds nothing.
tool_buffer = noone; //The last tool the player held before switching to building mode
knockBack = false;
knockPoint_x = 0;
knockPoint_y = 0;
climbSpeed = 2;
platformCollide = true;
deactivate_method = 0;

//Sprite stuff
image_speed = 10/60;
mask_index = spr_playerIdle;
armIndex = spr_armIdle;
armFrame = 0;
armAngle = 0;
armAngleGoal = 0;
armAngleRate = 0;
armOffset = 0; //Used for thrusting the arm forward or backward!
armOffsetGoal = 0;
armOffsetRate = 0;
armStabComplete = false;
toolAnimation = "SWING";
knockType = "LAND";
hForce = 0;
vForce = 0;

scr_swapPlayerSkin("BARRY");

//Initialize Player Stats
maxHp = 100; //Maximum health
hp = maxHp; //current health
canHurt = true; //The player can take damage.
hurtAlarm = 0; //The alarm to activate when hurt.
hsp_walk = 2; //Max walk speed
vsp_jump = -5; //Max jump speed
break_range = 2; //Tiles around the player that can be broken.
dead = false; //Whether or not the player is dead.
knock_resistance = 0.15;

//Tool variables
toolReady = true;
toolSprite = spr_sword;
toolFireRate = 40;
tool_shake_x = 0;
tool_shake_y = 0;
pitch_shift = true;
projSpeed = 3.5;
projDecay = 0.25;
projSprite = spr_projectile1;
weaponDamage = 4;
weaponKnockback = 3;
pickDamage = 1;
pickLevel = 0;
pickRange = 4;
g_over = false;
canUseTool = true;
hitSyncX = 0; //Hitbox Synchronizers
hitSyncY = 0;
playerLight = 0; //How bright light is underground.
tool_snd = noone;
shield_charges = 0;
compass_level = 0; //Each totem is associated with a compass level. A compass level of 2 will point the player in the direction of existing bliplo and nilmerg totems.
compass_target = noone; //Noone = no totem.
sling_jumps_set = 0;
sling_jumps_remaining = sling_jumps_set;
sling_cooldown_set = 60;
sling_cooldown = 0;
sling_force = 0; //Numbers for reference: 6 = pretty good/seashell tier; 15 = a huge jump.


//Tag Resets
globalvar bright_reset;
bright_reset = false; //Boolean to reset the light stat to 16. PROLLY NEEDS TO CHANGE IN THE FUTURE LOL

if room = rm_zero then g_over = gameOver;

friction = 0.3;

//Apply equipped accessories
scr_reloadAccessories();

//AUDIO
audio_listener_orientation(0,0,-1000,0,1,0);

//Tutorial tips
if tip_controls == false
{
    scr_createTip(1.5,1.75,"controls");
}

//SPAWN NOT INSIDE TILES
while place_meeting(x,y,PLRTILE) y-=16;
/*
scr_dropItem(ITEMID.weapon_meloniteChainsaw,0,ITEMTYPE.weapon,x,y,noone);
scr_dropItem(ITEMID.cons_melonChunk,99,ITEMTYPE.consumable,x,y,noone);
scr_dropItem(ITEMID.acc_copperSlingDrive,0,ITEMTYPE.accessory,x,y,noone);
scr_dropItem(ITEMID.cons_bomb,99,ITEMTYPE.consumable,x,y,noone);
scr_dropItem(ITEMID.item_dirtClump,99,ITEMTYPE.def,x,y,noone);
scr_dropItem(ITEMID.item_stonePiece,99,ITEMTYPE.def,x,y,noone);
scr_dropItem(ITEMID.item_copperOre,99,ITEMTYPE.def,x,y,noone);
scr_dropItem(ITEMID.item_stick,99,ITEMTYPE.def,x,y,noone);
scr_dropItem(ITEMID.acc_ultrablueStar,0,ITEMTYPE.accessory,x,y,noone);
scr_dropItem(ITEMID.acc_satchel,0,ITEMTYPE.accessory,x,y,noone);
scr_dropItem(ITEMID.acc_beehiveBackpack,0,ITEMTYPE.accessory,x,y,noone);
scr_dropItem(ITEMID.acc_copperChestplate,0,ITEMTYPE.accessory,x,y,noone);
scr_dropItem(ITEMID.acc_metalCompass,0,ITEMTYPE.accessory,x,y,noone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset animations &amp; tool ready
armIndex = spr_armIdle;
toolReady = true; 
armAngle = 0;
armOffset = 0;
armOffsetRate = 0;
hitSyncX = 0;
hitSyncY = 0;
tool_shake_x = 0;
tool_shake_y = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Respawn after death
g_over = gameOver;

if g_over == false
{
    //visible = true;
    x = obj_pie.x;
    y = obj_pie.y-32;
    while place_meeting(x,y,OBSTA) y-=16;
    hp = maxHp;
    dead = false;
    hForce = 0;
    vForce = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset canHurt;
canHurt = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement and Death Check
if dead = false &amp;&amp; g_over == false
{
    //Other variables
    var spr_height = sprite_get_height(sprite_idle)/2;
    var spr_width = sprite_get_width(sprite_idle)/2;

    //--- init platform variables ---
    var platformCollide; //Whether or not to collide with platforms at all.
    var on_platform; //Whether or not the gremlin is on a platform.

    if place_meeting_fast(0,2,obj_platform)
    {
        if instance_nearest(x,bbox_bottom,obj_platform).y &gt; y+6
        {
            on_platform = true;
        }
        else on_platform = false;
    } else on_platform = false;
    
    //--- init movement ---
    if knockBack == false
    {
        key_right = keyboard_check(global.key_right);
        key_left = keyboard_check(global.key_left);
        key_jump = keyboard_check(global.key_jump);
        key_down = keyboard_check(global.key_down);
    }
    
    hsp = (key_right - key_left) * hsp_walk;
    if vsp &lt; maxGrav then vsp = vsp + grav;
    
    //jump check
    if  vsp &gt;= 0 &amp;&amp; ((collision_point(x-3,bbox_bottom+1,OBSTA,false,true) || collision_point(x+2,bbox_bottom+1,OBSTA,false,true)) || on_platform)
    {
        if sling_cooldown &lt;= 0
        {
            sling_jumps_remaining = sling_jumps_set;
        }
    
        if key_jump
        {
            vsp = vsp_jump;
        }
    }
    
    
    
    //------Horizontal Movement---------
    var hdir = sign(hsp+hForce) //Horizontal Direction
    
    if hdir != 0 then image_xscale = hdir;
    if (place_meeting_fast(hsp+hForce,0,OBSTA))
    {
        //move as close as we can
        while (!place_meeting_fast(hdir,0,OBSTA))
        { x = x + hdir; }
        hsp = 0;
        hForce = 0;
    }
    
    x = x+hsp+hForce;
    hForce = approach(hForce,0,knock_resistance);
    
    
    
    
    //------Vertical Movement---------
    var vdir = sign(vsp+vForce); //up = -1, down = 1.
    var true_vsp = vsp+vForce;
    
    //-- Ladder Logic --
    if place_meeting_fast(0,0,obj_ladder)
    {
        //Stop falling
        if vsp != 0 { vsp = 0; }
        
        //-Climb the ladder
        if !place_meeting_fast(0,-climbSpeed,OBSTA) &amp;&amp; key_jump 
        {
            y-=climbSpeed;
        }
        else if !place_meeting_fast(0,climbSpeed,OBSTA) &amp;&amp; key_down 
        {
            y+=climbSpeed;
        }
        
        //Don't collide with platforms
        platformCollide = false;
    }
    
    
    //-- Collision with ground; else platform --
    //Complex Condition note: We have two complex coniditions, one is run when moving upward and checks corresponding points; two is run when moving downward and does the same.
    if true_vsp != 0 &amp;&amp; place_meeting_fast(0,true_vsp+1,OBSTA)//((true_vsp &gt; 0 &amp;&amp; (position_meeting(x-3,y+spr_height+true_vsp+1,OBSTA) || position_meeting(x+3,y+spr_height+true_vsp+1,OBSTA))) || (true_vsp &lt; 0 &amp;&amp; (position_meeting(x-3,y-spr_height+true_vsp+1,OBSTA) || position_meeting(x+3,y-spr_height+true_vsp+1,OBSTA))))
    {
        // Correct the while loop iterator in-case values are less than 1
        if true_vsp != 0 &amp;&amp; (true_vsp &lt; 1 || true_vsp &gt; -1)
        {
            vdir = true_vsp;
        }
    
        //move as close as we can
        while (!place_meeting_fast(0,vdir+1,OBSTA))
        { y += vdir; }
        vsp = 0;
        vForce = 0;
    }
    //-- PLATFORM COLLISION -- 
    else if !key_down &amp;&amp; instance_exists(obj_platform) &amp;&amp; vsp+vForce &gt; 0// &amp;&amp; platform_collide == true
    {
        
        var _plat = collision_line(x-3,bbox_bottom+true_vsp+1,x+3,bbox_bottom+true_vsp+2,obj_platform,false,true);
                
        if _plat != noone &amp;&amp; bbox_bottom &lt; _plat.y-6
        {            
            vForce = 0;
            vsp = 0;
            y = _plat.y-9-sprite_get_height(spr_playerIdle)/2;
        }
    }

    y = y+vsp+vForce;
    vForce = approach(vForce,0,knock_resistance);
    
    //Jump sprites
    if vsp != 0 &amp;&amp; !place_meeting_fast(0,1,OBSTA) &amp;&amp; !on_platform
    {
        if sprite_index != sprite_jump then sprite_index = sprite_jump;
        if armIndex != sprite_arm_jump &amp;&amp; armAngle == 0 then armIndex = sprite_arm_jump;
        if y &gt; yprevious then image_index = 1 else image_index = 0;
        armFrame = image_index;
        platformCollide = false;
    }
    
    ///Knockback
    if knockBack == true
    {
        if hForce+vForce == 0 { knockBack = false; }
    }
    
    
    //------------------Sprites--------------------
    switch state
    {
        case IDLE:
        {
            if sprite_index != sprite_idle &amp;&amp; vsp == 0 then sprite_index = sprite_idle;
            if armIndex != sprite_arm_idle &amp;&amp; armAngle == 0 &amp;&amp; vsp == 0 then armIndex = sprite_arm_idle;
            if image_speed != 10/60 then image_speed = 10/60;
            
            if hsp != 0 then state = MOVE;
        }
        break;
    
        case MOVE:
        {
            if sprite_index != sprite_walk &amp;&amp; (collision_point(x,1+bbox_bottom,OBSTA,false,true) || collision_point(x,2+bbox_bottom,obj_platform,false,true) ) then sprite_index = sprite_walk;
            if armIndex != sprite_arm_walk &amp;&amp; armAngle == 0 &amp;&amp; vsp == 0 then armIndex = sprite_arm_walk;
            if image_speed != (14+((hsp_walk)/10))/60 then image_speed = (14+((hsp_walk)/10))/60;
            
            if hsp == 0 then state = IDLE;
        }
        break;
    }
    
    if armAngle == 0 { armFrame = image_index; } else armFrame = 0;
    
    //Animate Arm movement
    //- Swing
    if armAngle != 0 &amp;&amp; toolAnimation == "SWING" &amp;&amp; tool != 4
    {
        //Move the arm back to 0.
        if armAngle &gt; armAngleGoal
        { 
            armAngle = approach(armAngle,armAngleGoal,armAngleRate);
            
            //Do not let armAngle = 0, this will stop the animation.
            if armAngle == 0 then armAngle = 0.1;
            
            if armAngle &lt;= armAngleGoal 
            { 
                armIndex = sprite_arm_idle;
                toolReady = true; 
                armAngle = 0; 
            }
        }
        
    
    //---Stab--- 
       
    } 
    else if toolAnimation == "STAB" &amp;&amp; tool != 4
    {
        if armStabComplete == false
        {
            if armOffset &lt; armOffsetGoal 
            { armOffset += armOffsetRate }
            else
            { armStabComplete = true; }
        } 
        else
        {
            armOffset -= armOffsetRate;

            if armOffset &lt;= 0
            {
                //Reset to default values
                //- arm index doesn't need to reset.
                toolReady = true;
                armStabComplete = false;
                armOffset = 0;
                armOffsetRate = 0;
                armOffsetGoal = 0;
                hitSyncX = 0;
                hitSyncY = 0;
            }
        }
        //- cute little magic used for simulating 360 degrees of arm movement that isn't actually real ;-;
        var _dir = point_direction(x,y,mouse_x,mouse_y);
            
        //- prepare _dir for further processing...
        if image_xscale == -1 then _dir = (_dir-180)*-1;
        
        hitSyncY = y+lengthdir_y((armOffset),_dir);
        hitSyncX = x+lengthdir_x((armOffset)*image_xscale,_dir);
    }
    else if toolAnimation == "SHOOT" &amp;&amp; ( tool == 2 || tool == 1) &amp;&amp; toolReady == false
    {
        //Aim towards the mouse!
        var _dir = point_direction(x,y,mouse_x,mouse_y);
        image_xscale = sign(mouse_x-x);
        armIndex = sprite_arm_swing; //Still a straight arm.
        if image_xscale == 1 then armAngle = _dir else armAngle = (_dir-180)*-1;
        hitSyncY = y+lengthdir_y((armOffset),_dir);
        hitSyncX = x+lengthdir_x((armOffset)*image_xscale,_dir);
    }
    
    //Face mouse when using item
    if mouse_check_button(mb_left) &amp;&amp; hudControl.cursorHoldItem == false
        { if mouse_x != x then image_xscale = sign(mouse_x-x); }
        
    //----- Sling-Drive ----
    if (keyboard_check_pressed(global.key_sling) &amp;&amp; sling_jumps_remaining &gt; 0)
    {
        vsp = 0;
        vForce = 0;
        hspd = 0;
        hForce = 0;
        
        sling_cooldown = sling_cooldown_set;
        sling_jumps_remaining -= 1;
        
        //movement
        hForce = sling_force*(key_right-key_left);
        vForce = sling_force*(key_down-key_jump);
        
        //i-frames
        canHurt = false;
        alarm[0] = (sling_force+1)*2;
        
        //sound
        audio_play_sound(snd_dash,11,false);
    }
    
    //- cooldown
    if (sling_cooldown &gt; 0)
    {
        sling_cooldown -= 1;
        
        if sling_cooldown &lt;= 0
        {
            sling_jumps_remaining = sling_jumps_set;
        }
        
        //particle
        if sling_cooldown &gt; (sling_cooldown_set*0.75)
        {
            part_particles_create(particle_system,x,y,part_esc,irandom_range(8,12));
        }
    }
    
    //- be sure to reset numbers from accessory abuse
    if sling_jumps_set &lt; 0 then sling_jumps_set = 0;
    if sling_jumps_remaining &lt; 0 then sling_jumps_remaining = 0;
    if sling_cooldown_set &lt; 0 then sling_cooldown_set = 60;
    if sling_cooldown &lt; 0 then sling_cooldown = 0;
    if sling_force &lt; 0 then sling_force = 0;
        
}
    
    
    
//---------check for death-----------
if dead == false
{
    if hp &lt;= 0 || g_over == true
    {
        dead = true;
        alarm[1] = room_speed*20-(interm*60*15);
        //visible = false;
        
        //LOSE ESSENCE
        var essence_lost = ceil(currency_essence*0.15);
        
        scr_removeEssence(essence_lost);
        scr_hudMessage(string(essence_lost)+" essence lost...",global.fnt_Ui,5,0,c_red,0);
        
        //Respawn at the pie
        x = obj_pie.x;
        y = obj_pie.y;
    }
    
//---AUDIO LISTENENR POSITION----
audio_listener_position(x,y,0);
}

//Remain inside the room at all times
x = clamp(x,0,room_width);
y = clamp(y,0,room_height);

//Arm calculations will sometimes cause image_xscale to be zero.
if image_xscale != 1 &amp;&amp; image_xscale &gt;= 0 then image_xscale = 1
else if image_xscale != -1 &amp;&amp; image_xscale &lt; 0 then image_xscale = -1;

//HP clamp
hp = clamp(hp,0,maxHp);

//print(region);

//Can hurt animation
if canHurt == false &amp;&amp; dead == false
{
    image_alpha = approach(image_alpha,0,0.1);
    
    if image_alpha = 0 then image_alpha = 1;
}
else if image_alpha != 1
{
    image_alpha = approach(image_alpha,1,0.1);
}

//---Shake certain tools---
if (armIndex != spr_armWalk &amp;&amp; armIndex != spr_armIdle &amp;&amp; armIndex != spr_armJump) &amp;&amp; (toolSprite == spr_melonite_chainsaw || toolSprite == spr_stingerDrill)
{
    tool_shake_x += choose(1,-1);
    tool_shake_x = clamp(tool_shake_x,-2,2);
    tool_shake_y += choose(1,-1)
    tool_shake_y = clamp(tool_shake_y,-2,2);;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interact &amp; Quick Heal
//-------INTERACT KEY------------
if keyboard_check_released(global.key_interact)
{
    //Interact with objects that aren't crafting
    if instance_exists(INTERACT)
    {
        var interact = instance_nearest(x,y,INTERACT);
        
        if distance_to_point(interact.x,interact.y) &lt; 32 &amp;&amp; interact.bench == false
        {
            with interact event_user(0);
        }
    }
}

//-----QUICK HEAL KEY----------
if keyboard_check_released(global.key_quick_heal) &amp;&amp; obj_player.dead == false
{
    if hp &lt; maxHp
    {
        //List of items to look for.
        var heal_list = array_create(1);
        heal_list[0] = ITEMID.cons_treeFruit;
        heal_list[1] = ITEMID.cons_melonChunk;
        
        //Quickly heal by searching for the first healing item in the inventory and eating it!
        var loop_size = array_length_1d(heal_list);
        
        for(i=0;i&lt;loop_size;i++)
        {
            //Find the item's 
            var heal_slot = scr_findInvenItem(heal_list[i]);
            
            if heal_slot != noone
            {
                scr_useConsumable(hudControl.inventorySlotIcon[heal_slot]);
            }
            else if i == loop_size-1
            {
                audio_play_sound(snd_invalid,12,false);
                scr_popMessage("No healing items",global.fnt_menu,1,c_red,x-8,y);
            }
        }
    }
    else if hp &gt;= maxHp
    {
        audio_play_sound(snd_invalid,12,false);
        scr_popMessage("HP full",global.fnt_menu,1,c_red,x-8,y);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then y += 5;

//x = obj_pie.x;
//y = obj_pie.y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then x += 5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then y -= 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then x -= 5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Use Tool
//Check for inventory use
if dead == false &amp;&amp; hudControl.settingsMenu == false &amp;&amp; hudControl.selectedSlot != noone &amp;&amp; hudControl.equipQueue == noone &amp;&amp; hudControl.showSuperMenu == false
{
    var dx = device_mouse_x_to_gui(0)
    var dy = device_mouse_y_to_gui(0)
    
    //Defines the crafting menu's dimensions.
    var _cmX = view_wview[0]/2-120;
    var _cmY = view_hview[0]/2-105;
    
    if 
        //- Inventory stipulations
        !point_in_rectangle(dx,dy,0,5,125,15) &amp;&amp; !point_in_rectangle(dx,dy,0,50,hudControl.invenX,70) 
        &amp;&amp; hudControl.cursorHoldItem == false &amp;&amp;
        
        //- Crafting Menu stipulations
        !(hudControl.showSuperMenu == true &amp;&amp; point_in_rectangle(dx,dy,_cmX,_cmY,250+_cmX,200+_cmY))
    {
        //- Variable declarations and rules
        var slot = hudControl.selectedSlot;
        if slot == noone then exit;
        
        var item = hudControl.inventorySlotIcon[slot];
        if item == 0 then exit;
        
        //-----SOUND------
        if tool_snd != noone &amp;&amp; toolReady == true &amp;&amp; (tool == 2 || tool == 1)
        {
            var snd = noone;
        
            switch tool_snd
            {
                case "SWISH": { snd = choose(snd_swish1,snd_swish2,snd_swish3,snd_swish4); } break;
            
                default: snd = tool_snd;
            }
        
            audio_play_sound(snd,10,false);
            if pitch_shift = true then audio_sound_pitch(snd,choose(0.92,1,1.07));
        }
        
        
        //-------USE THE TOOL !----------
        switch tool
        {
            case 1:
            {
                //Weapon slot
                if toolReady == true
                {
                    //Use weapon
                    scr_useWeapon(proj_type,projSpeed,projDecay,projSprite,weaponDamage,weaponKnockback);
                    
                    switch toolAnimation
                    {
                        case "SWING":
                        {
                            armIndex = sprite_arm_swing;
                            armAngleGoal = -60; //Down somewhat
                            armAngle = 90; //Straight up
                            armAngleRate = (180/toolFireRate)+1;
                            toolReady = false;
                        }
                        break;
                        
                        case "SHOOT":
                        {
                            var _dir = point_direction(x,y,mouse_x,mouse_y);
                            
                            image_xscale = sign(mouse_x-x);
                        
                            armIndex = sprite_arm_swing; //Still a straight arm.
                            if image_xscale = 1 then armAngle = _dir else armAngle = (_dir-180)*-1;
                            
                            toolReady = false;
                            alarm[2] = toolFireRate;
                        }
                        break;
                        
                        case "STAB":
                        {   
                            //Initialize Animation
                            var _dir = point_direction(x,y,mouse_x,mouse_y);
                            
                            image_xscale = sign(mouse_x-x);
                        
                            armIndex = sprite_arm_swing; //Still a straight arm.
                            if image_xscale = 1 then armAngle = _dir else armAngle = (_dir-180)*-1;
                            toolReady = false;
                            alarm[2] = toolFireRate;
                            
                            armOffset = 0;
                            armOffsetGoal = 20;
                            armOffsetRate = (armOffsetGoal*2)/toolFireRate;
                            armStabComplete = false;
                        }
                        break;
                    }
                }
            }
            break;
            
            case 2:
            {
                //Pickaxe Slot
                if toolReady == true
                {
                    scr_usePickaxe(pickDamage,pickLevel);
                    
                    switch toolAnimation
                    {
                        case "SWING":
                        {
                            armIndex = sprite_arm_swing;
                            armAngleGoal = -60; //Down somewhat
                            armAngle = 90; //Straight up
                            armAngleRate = (180/toolFireRate)+1; //180 is a number larger than the goal. This calculation will always result in an angle rate that is fast enough to finish the animation.
                        }
                        break;
                        
                        case "SHOOT":
                        {
                            //local variables are the same as SWING and is meant to synchronize SHOOT animation times with SWING animation times via calculation.
                            armIndex = sprite_arm_swing; //Still a straight arm.
                            var _armAngleGoal = -60; //Down somewhat
                            var _armAngle = 90; //Straight up
                            var _armAngleRate = (180/toolFireRate)+1;
                            
                            //if _armAngle move at _armAbleRate, how long will it take to reach _armAngleGoal?
                            alarm[2] = ((150*(180/toolFireRate))/room_speed)+1;
                        }
                        break;
                    }
                    
                    toolReady = false;
                }
            }
            break;
            
            case 4:
            {
                //Consumable
                if toolReady == true &amp;&amp; room == rm_zero &amp;&amp; obj_player.dead == false
                {
                    scr_useConsumable(hudControl.inventorySlotIcon[slot]);
                    toolReady = false;
                }
            }
            break;
            
            case ITEMTYPE.accessory:
            {
                if toolReady == true
                {
                    //Equip/Dequip the accessory
                    scr_applyAccessory(item);
                    
                    toolReady = false;
                    toolAnimation = "SWING";
                    armIndex = sprite_arm_swing;
                    armAngleGoal = 71;
                    armAngle = 70; //Straight up
                    armAngleRate = 0;
                    toolSprite = spr_nothing;
                    alarm[2] = room_speed/2;
                }
            }
            break;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw body
if dead == false
{
    draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,0,c_white,image_alpha);
    
    //draw arms
    //- Draw tool
    if toolReady == false 
    {
        switch toolAnimation
        {
            case "SWING":
            {
                draw_sprite_ext(toolSprite,current_time/100,x+lengthdir_x(11*image_xscale,armAngle),y-lengthdir_y(-10,armAngle)-2,image_xscale,image_yscale,armAngle*image_xscale,c_white,1);
            } 
            break;
            
            case "SHOOT":
            {
                draw_sprite_ext(toolSprite,current_time/100,x+lengthdir_x(11*image_xscale,armAngle)+tool_shake_x,y-lengthdir_y(-10,armAngle)-2+tool_shake_y,image_xscale,image_yscale,armAngle*image_xscale,c_white,1);
            }
            break;
            
            case "STAB":
            {
                if armOffset == 0 then break;
                //Click to deathpoke the Gremlins.
                //- cute little magic used for simulating 360 degrees of arm movement that isn't actually real ;-;
                var _dir = point_direction(x,y,mouse_x,mouse_y);
                
                //- prepare _dir for further processing...
                if image_xscale == -1 then _dir = (_dir-180)*-1;
                
                var yOffset = lengthdir_y((armOffset),_dir);
                var xOffset = lengthdir_x((armOffset)*image_xscale,_dir);
                
                draw_sprite_ext(toolSprite,current_time/100,x+xOffset,y+yOffset,image_xscale,image_yscale,_dir*image_xscale,c_white,1);
                //- STAB arm animator
                draw_sprite_ext(armIndex,armFrame,x+tool_shake_x,y+tool_shake_y,image_xscale,image_yscale,_dir*image_xscale,c_white,1);
            }
            break;
        }
    }
    
    //- Default arm animator
    if armOffset == 0
    { draw_sprite_ext(armIndex,armFrame,x+tool_shake_x,y+tool_shake_y,image_xscale,image_yscale,armAngle*image_xscale,c_white,image_alpha); }
}
else if dead == true
{
    ///-- RESPAWN TIMER --
    draw_text(x-50,y,"Respawning... "+string(alarm_get(1) div 60));
}

//Compass level
if y &gt; stoneLayer &amp;&amp; compass_level &gt; 0 &amp;&amp; instance_exists(TOTEM)
{
    if compass_level == 1
    {
        //level 1 only finds hive totems.
        var _t = instance_find(TOTEM, 0);
        if ( _t.object_index == obj_hiveTotem )
        {
            compass_target = _t;
        }
    }
    else if compass_level == 2
    {
        //level 2 will find all totem types.
        var _t = instance_find(TOTEM, 0);
        compass_target = _t;
    }
    
    //Draw the compass indicator
    
    if instance_exists(compass_target)
    {
        var _len = 16;
        var _dir = point_direction(x,y,compass_target.x,compass_target.y);
        draw_sprite_ext(spr_compass_arrow,0,x+lengthdir_x(_len,_dir),y+lengthdir_y(_len,_dir),0.5,0.5,_dir+90,c_white,1);
    }
}
else
{
    compass_target = noone;
}
//SLING DEBUGGING
/*
draw_text(x,y,"jumps: "+string(sling_jumps_remaining));
draw_text(x,y+5,"cd: "+string(sling_cooldown));

//PLATFORM DEBUGGING

var on_platform; //Whether or not the gremlin is on a platform.

if place_meeting_fast(0,2,obj_platform)
{
    if instance_nearest(x,y+1,obj_platform).y &gt; y+6
    {
        on_platform = true;
    }
    else on_platform = false;
} else on_platform = false;

draw_text(x,y+10,string(on_platform));
draw_text(x,y,string(y));
var spr_height = bbox_bottom;
draw_rectangle(x-3,spr_height-2,x+3,spr_height+2,false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="116">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if sprite_idle = spr_tadIdle
{
    scr_swapPlayerSkin("BARRY");
}
else if sprite_idle = spr_playerIdle
{
    scr_swapPlayerSkin("TIME");
}
else if sprite_idle = spr_timeGuyIdle
{
    scr_swapPlayerSkin("TAD");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="100">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>print(instance_number(obj_projectile));
/*if dev != true then exit;
instance_create(x,y,region_shifter);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="99">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(mouse_x,mouse_y,obj_gremlin);

/*if dev != true then exit;
scr_dropItem(ITEMID.item_stonePiece,99,0,x,y,noone);
scr_dropItem(ITEMID.item_dirtClump,99,0,x,y,noone);
scr_dropItem(ITEMID.item_gremEssence,99,0,x,y,noone);
scr_dropItem(ITEMID.item_copperOre,99,0,x,y,noone);
scr_dropItem(ITEMID.item_seashellMetal,99,0,x,y,noone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="97">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev != true then exit;
//scr_spawnEssence(currency_essence,4,10);
instance_create(mouse_x,mouse_y,obj_melonster);
/*
if instance_exists(worldControl.raidBossID)
{
worldControl.raidBossID.x = -16;
worldControl.raidBossID.y = -16;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
