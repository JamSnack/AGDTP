<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>99</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize world variables
globalvar grav,maxGrav,loadStep,wave,interm,enemyActiveList,RAIDBOUND_Upper,RAIDBOUND_Lower,raidProgress,maxRaidProgress,stoneLayer,specialRaid,nextRaid,world_Time;
grav = 0.350;
maxGrav = 5;
loadStep = 0; //Load the world.
wave = 0; //Wave number
interm = true; //intermission boolean
enemyActiveList[0] = noone; //List of enemies that require chunking.
raidProgress = 0; //How many more gremlins need to die before the raid is complete.
maxRaidProgress = 100; //Raid goal.
stoneLayer = (room_height/2-48)+(10*16); //Around the layer of stone

if room == rm_zero 
{
    scr_loadWorld();
    scr_raidControl("INTERM",0,0,0,0); //Preset setting, other arguments not required.
    alarm[0] = 1;
    alarm[1] = 120;
    plr_xBuffer = 0;
    plr_yBuffer = 0;
}

//Local variables
world_Time = 0;
heal_Time = 10; //Heal something (defense) every interval.
playerTiles = 0;
view_zoom_buffer = 0; //Remember the last value of the zoom.
maxGrem = 5; //Maximum gremlins in the world.
spawnRate = 1; //How many times a second to check for and spawn a thing.
spawnChance = 0; //The chance that the thing will spawn out of 100.
raidBoss = false; //No raid boss.
raidBossID = noone; //The instance ID of the boss.
nextRaid = "RAID"; //The next raid's type.
specialRaid = false; //Bool telling whether or not a special raid is in progress.
special_raidID = noone; //The ID of the raid
world_TimeMax = room_speed*(3*60);
dayTransition = false; //Whether or not to transition into day;
dayAlpha = 0;

global.light_surface = surface_create(display_get_width(),display_get_height());

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn gremlins

var _viewX = view_xview[0];
var _viewW = view_wview[0]+_viewX;
var _viewY = view_yview[0];
var _viewH = view_hview[0]+_viewY;


if instance_number(ENEMY) &lt; maxGrem &amp;&amp; irandom(100) &lt;= spawnChance
{
    var outer_x_range = 2*16; //Defines how many tiles outside the xview the enemy can spawn.
    if interm == false then outer_x_range = 5;
    //var outer_y_range = irandom_range(1,5)*16; //Defines how many tiles outside the yview the enemy can spawn.
    
    var xx = choose(_viewX,_viewW);
    var yy = choose(_viewY,_viewH);
    var xdir = sign(xx-obj_player.x);
    
    //Change xx coordinate
    xx = xx+(xdir*irandom(outer_x_range));
      
    //Center points
    xx = floor(xx/16)*16;
    yy = floor(yy/16)*16;
    
    //Spawn mobs outside flat lands + (or during raids)
    var spawn_at_portal = false;
    
    if (xx &gt;= RAIDBOUND_Lower &amp;&amp; xx &lt;= RAIDBOUND_Upper) || interm == false
    {
        xx = choose(RAIDBOUND_Lower-16,RAIDBOUND_Upper+16); 
        yy = (room_height/2)-(16*4);
        spawn_at_portal = !interm; //if interm == false then spawn_at_portal = true;
    }
    
    //Gremlins spawn on top of stuff
    while position_meeting(xx,yy,OBSTA) yy-=16;
    
    //Spawn gremlin
    var flyChance = 0.3;
    var gremNumber = random(1);
    
    //-Check whether or not the enemy will spawn inside the view.
    if !point_in_rectangle(xx,yy,_viewX,_viewY,_viewW,_viewH)
    {
        //--SpawnGremlins directly ontop of a tile from the sky
        while (!position_meeting(xx,yy+16,TILE_ALL) &amp;&amp; !position_meeting(xx,yy+16,GREM_BLOCK)) { yy+=16; if yy &gt; room_height then break; }
        
        new_raidGremlin(xx,yy,gremNumber,flyChance,special_raidID);
        
        //Special mob spawns.
            //-Sphere Pylon
        if interm == true
        {
            if irandom(50) &gt;= 48
            {
                instance_create(xx,yy,obj_spherePylon);
            }
        }
    } else if spawn_at_portal == true { new_raidGremlin(xx,yy,gremNumber,flyChance,special_raidID); }
    
    //Clear active mob roster
    if array_length_1d(enemyActiveList) &gt; 3 { enemyActiveList = 0; }
    
    
} else if instance_number(ENEMY) &gt;= maxGrem
{
    //Despawn an offview gremlin.
    for (i=0;i&lt;instance_number(ENEMY);i++)
    {
        var grem = instance_find(ENEMY,i);
        var gx = grem.x;
        
        //Don't despawn the boss
        if grem == raidBossID then break;
        
        //Don't despawn things inside the Flatlands
        if !(gx &gt;= RAIDBOUND_Lower &amp;&amp; gx &lt;= RAIDBOUND_Upper)
        {
            //Check whether or not the gremlin is visible.
            if !point_in_rectangle(grem.x,grem.y,_viewX,_viewY,_viewW,_viewH)
            {
                with grem { dropItem = false; instance_destroy(); }
                break;
            }
        }
    }
}

alarm[1] = room_speed/spawnRate;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Deactivation/Chunking and World Time
if interm == true 
{
    world_Time += 10;
    heal_Time += 1;
}

var playerX = obj_player.x;
var playerY = obj_player.y;
var view_zoom = camera.view_zoom;
var playerLight = obj_player.playerLight;

//----Deactivation---------
if view_zoom != view_zoom_buffer
{
    //Update view_zoom
    view_zoom = view_zoom_buffer;
    
    //-Deactivation and Reactivation updates every two tiles.
    if (abs(playerX-plr_xBuffer) &gt; 32 || abs(playerY-plr_yBuffer) &gt; 32)
    {
            
        //-Activate everything inside the camera view.
        var outerBoundary = 10*16; //-"offscreen" boundary distance from view. 10 tiles
        var enemyBoundary = 5*16; //-tiles enemies are allowed to have active.
        instance_activate_region(view_xview[0]-outerBoundary,view_yview[0]-outerBoundary,450+2*(outerBoundary),450+2*(outerBoundary),true);
        
        //Keep saplings active.
        if instance_exists(obj_sapling)
        {   instance_activate_object(obj_sapling); }
        
        //-Deactivate offscreen objects.
        with obj_itemDrop scr_deactivateOffscreen(id);
        with TILE if object_index != obj_pie { scr_deactivateOffscreen(id); }
        with INTERACT scr_deactivateOffscreen(id);
        with NOCOL if object_get_parent(id) != PLR_NOCOL then scr_deactivateOffscreen(id);
        
        //-Update player buffer
        plr_xBuffer = round(playerX);
        plr_yBuffer = round(playerY);
        
        //-Activate offscreen tiles for needed enemies.
        if array_length_1d(enemyActiveList) &gt; 0
        {
            for (i=0;i&lt;array_length_1d(enemyActiveList);i++)
            {
                with enemyActiveList[i]
                {
                 instance_activate_region(x-enemyBoundary,y-enemyBoundary,x+enemyBoundary,y+enemyBoundary,true);
                }
            }
        }
    }
}

//-----------Light up underground tiles----------------
//Updates every tile.
if (abs(playerX-plr_xBuffer) &gt; 15 || abs(playerY-plr_yBuffer) &gt; 15)
{
    
    if playerY &gt; stoneLayer-48
    {
        with TILE
        {
            if light_level &lt; 255
            {
                var dist = point_distance(x,y,playerX,playerY);
                var light_dist = floor(255-dist*2.5);
                
                if dist &lt; playerLight*2
                { light_level = 255;}
                else if light_dist &lt;= 255 &amp;&amp; light_dist &gt; 0  { light_level = light_dist; }
                else light_level = 0;
            }
        }
        
        with obj_nullLight
        {
            if light_level &lt; 255
            {
                var dist = point_distance(x,y,playerX,playerY);
                var light_dist = floor(255-dist*2.5);
                
                if dist &lt; playerLight*2
                { instance_destroy(); }
                else if light_dist &lt;= 255 &amp;&amp; light_dist &gt; 0  { light_level = light_dist; }
                else light_level = 0;
            }
        }
    }
}


//------------- Proliferate every tick ---------------------------
if heal_Time &gt;= room_speed
{
    with PLRTILE event_user(15);
    with PLR_NOCOL event_user(15);
    with obj_pie event_user(1);
    if obj_player.hp != obj_player.maxHp &amp;&amp; obj_player.dead == false with obj_player { hp += 1; if hp &gt;= maxHp then hp = maxHp; }
    
    heal_Time = 0;
}

//------------ World Time -------------------
// multiplied by 3 into 3 minutes.

if world_Time &gt;= world_TimeMax //3 minutes
{
    world_Time = 0;
    scr_raidControl(nextRaid,0,0,0,0); //Preset raid
}




alarm[0] = 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///D/N Cycle Alpha
var aMax = 0.6;

if interm == true
{
    //Alpha = equation to get the darkness of the day until til night
    if dayTransition == true
    {
        if dayAlpha &gt; 0 { dayAlpha -= 0.01; } else dayTransition = false;
    }
    else dayAlpha = ((world_Time/world_TimeMax));
    
    dayAlpha = clamp(dayAlpha,0,aMax);
} else if interm == false then dayAlpha = aMax;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Event: RAID_PROGRESSED
print('Raid Progressed');

//Increase progress meter
if raidProgress &lt;= maxRaidProgress
{
    if raidBoss == false { raidProgress += 1 }
    else if raidProgress &gt;= 99 then raidProgress = 99;
}



//-------RAID DEFEATED EVENT---------

//Check for completion
if raidProgress &gt;= maxRaidProgress
{
    print('Raid Complete');
    scr_raidControl("INTERM",0,0,0,0);
    
    //Grow trees
    if instance_exists(obj_sapling)
    { 
        with obj_sapling
        {
            var r = irandom(10);
            if r &lt;= 7
            {
                scr_treeCreate(x,y);
                instance_destroy();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Day and night cycle
draw_set_color(make_colour_hsv(240,100,17));
draw_set_alpha(dayAlpha);
//draw_rectangle(0,0,display_get_width(),display_get_height(),false);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="66">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then scr_raidControl(nextRaid,0,0,0,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
