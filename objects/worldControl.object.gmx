<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>99</depth>
  <persistent>0</persistent>
  <parentName>CONTROL</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize world variables
event_inherited();
globalvar grav,maxGrav,loadStep,wave,interm,enemyActiveList,RAIDBOUND_Upper,RAIDBOUND_Lower,raidProgress,maxRaidProgress,stoneLayer,specialRaid,nextRaid,world_Time,energy,difficulty,current_grem,kingDied_1,kingDied_2,turret_capacity;
grav = 0.350;
maxGrav = 5;
loadStep = 0; //Load the world.
wave = 0; //Wave number
interm = true; //intermission boolean
enemyActiveList[0] = noone; //List of enemies that require chunking.
raidProgress = 0; //How many more gremlins need to die before the raid is complete.
maxRaidProgress = 100; //Raid goal.
stoneLayer = (room_height/2-48)+(10*16); //Around the layer of stone
energy = 0; //NOTE: CURRENTLY REPLACING WITH turret_capacity; 11/9/21
turret_capacity = 0;
current_grem = 0; //Number of gremlins in the world based on their spawn weight.


//- boss checklist
kingDied_1 = false; //Whether or not Nilmerg has been defeated.
kingDied_2 = false; //Whether or not Bliplo has been defeated.

//local variable that needs to be set before scr_raidControl :)
region_shift = false; //Whether or not to shift the region next intermission.
special_raidID = "";


//Local variables
world_Time = 0;
heal_Time = 10; //Heal something (defense) every interval.
playerTiles = 0;
view_zoom_buffer = 0; //Remember the last value of the zoom.
maxGrem = 5; //Maximum gremlins in the world.
spawnRate = 1; //How many times a second to check for and spawn a thing.
spawnChance = 0; //The chance that the thing will spawn out of 100.
raidBoss = false; //No raid boss.
raidBossID = noone; //The instance ID of the boss.
nextRaid = "RAID"; //The next raid's type.
specialRaid = false; //Bool telling whether or not a special raid is in progress.
special_raidID = noone; //The ID of the raid
world_TimeMax = room_speed*(5*60);
dayTransition = false; //Whether or not to transition into day;
dayAlpha = 0;
deactivation_enabled = true;
shift_destination = "";

if room == rm_zero 
{
    scr_loadWorld(noone);
    scr_raidControl("INTERM",0,0,0,0); //Preset setting, other arguments not required.
    plr_xBuffer = 0;
    plr_yBuffer = 0;
    alarm[0] = 0;
    alarm[1] = 120;
}
else if room == rm_tutorial
{
    scr_loadWorld("TUTORIAL");
    scr_raidControl(0,0,0,0,0); //Tutorial stuff
    alarm[0] = 1;
    alarm[1] = 120;
    plr_xBuffer = 0;
    plr_yBuffer = 0;
    with worldControl { event_user(1); }
}

//global.light_surface = surface_create(display_get_width(),display_get_height());

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update visibility
//NOTE: Update visibility every 4 frames.
with PAUSE
{
    var parent = object_get_parent(object_index);
    if parent != EFFECT &amp;&amp; parent != CONTROL &amp;&amp; parent != TILE_ALL
    {   
        visible = scr_tileVisibleCheck(bbox_left,bbox_top,bbox_right,bbox_bottom);
    }
}

alarm[2] = floor(120/(fps))*5;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn gremlins
var _viewX = view_xview[0];
var _viewW = view_wview[0]+_viewX; //wview is a constant denoting the size of the view.
var _viewY = view_yview[0];
var _viewH = view_hview[0]+_viewY;


if current_grem &lt; maxGrem &amp;&amp; irandom(100) &lt;= spawnChance &amp;&amp; !(wave == 0 &amp;&amp; world_Time &lt; 60*15)
{
    var outer_x_range = 2*16; //Defines how many tiles outside the xview the enemy can spawn.
    if interm == false then outer_x_range = 5;
    //var outer_y_range = irandom_range(1,5)*16; //Defines how many tiles outside the yview the enemy can spawn.
    
    var xx = choose(_viewX,_viewW);
    var yy = choose(_viewY,_viewH);
    var xdir = sign(xx-obj_player.x);
    
    //Change xx coordinate
    xx = xx+(xdir*irandom(outer_x_range));
      
    //Center points
    xx = floor(xx/16)*16;
    yy = floor(yy/16)*16;
    
    //Spawn mobs outside flat lands + (or during raids)
    var spawn_at_portal = false;
    
    if (xx &gt;= RAIDBOUND_Lower &amp;&amp; xx &lt;= RAIDBOUND_Upper) || interm == false
    {
        xx = choose(RAIDBOUND_Lower-16,RAIDBOUND_Upper+16); 
        yy = (room_height/2)-(16*4);
        spawn_at_portal = !interm; //if interm == false then spawn_at_portal = true;
    }
    
    //Gremlins spawn on top of stuff
    while position_meeting(xx,yy,OBSTA) yy-=16;
    
    //Spawn gremlin
    var specialChance = 0.3;
    var gremNumber = random(1);
    
    //-Check whether or not the enemy will spawn inside the view.
    if !point_in_rectangle(xx,yy,_viewX,_viewY,_viewW,_viewH)
    {
        //--SpawnGremlins directly ontop of a tile from the sky
        while (!position_meeting(xx,yy+16,TILE_ALL) &amp;&amp; !position_meeting(xx,yy+16,GREM_BLOCK)) { yy+=16; if yy &gt; room_height then break; }
        
        new_raidGremlin(xx,yy,gremNumber,specialChance,special_raidID);
        
        //Special mob spawns.
            //-Sphere Pylon
        if interm == true
        {
            if irandom(100) == 55 &amp;&amp; nextRaid != "SPHERE" &amp;&amp; wave != 0
            {
                instance_create(xx,yy,obj_spherePylon);
            }
        }
    } else if spawn_at_portal == true { new_raidGremlin(xx,yy,gremNumber,specialChance,special_raidID); }
    
    //Clear active mob roster
    if array_length_1d(enemyActiveList) &gt; 3 { enemyActiveList = 0; }
    
    
} 
else if current_grem &gt;= maxGrem
{
    //Despawn an offview gremlin.
    for (i=0;i&lt;instance_number(ENEMY);i++)
    {
        var grem = instance_find(ENEMY,i);
        var gx = grem.x;
        var gy = grem.y;
        
        //Don't despawn the bosses
        if grem == raidBossID || grem.canDespawn == false then continue;
        
        //Don't despawn things inside the Flatlands and above the stone layer
        if !(gx &gt;= RAIDBOUND_Lower &amp;&amp; gx &lt;= RAIDBOUND_Upper) &amp;&amp; (gy &gt;= stoneLayer)
        {
            //Check whether or not the gremlin is visible.
            if !point_in_rectangle(gx,gy,_viewX,_viewY,_viewW,_viewH)
            {
                with grem { dropItem = false; instance_destroy(); }
                break;
            }
        }
    }
}

alarm[1] = room_speed/spawnRate;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Deactivation/Chunking and World Time
alarm[0] = 1;

//if deactivation_enabled == false then exit;
if !instance_exists(obj_player) then exit;

//- time control
if interm == true 
{ world_Time += 1; }

heal_Time += 1;

//Failsafe for left-over spawn weight.
if current_grem != 0 &amp;&amp; !instance_exists(ENEMY)
{ 
    print("ERROR: spawn_weight imbalance corrected.");
    current_grem = 0;
}

//- init logic
var playerX = obj_player.x;
var playerY = obj_player.y;
var view_zoom = camera.view_zoom;
var playerLight = obj_player.playerLight;

var player_distance_amt_x = abs(playerX-plr_xBuffer);
var player_distance_amt_y = abs(playerY-plr_yBuffer);

//----Deactivation---------
if view_zoom != view_zoom_buffer
{
    //Update view_zoom
    view_zoom = view_zoom_buffer;
    
    //-Deactivation and Reactivation updates every eight tiles.
    if (player_distance_amt_x &gt; 16*16 || player_distance_amt_y &gt; 16*16)
    {
    
       /* SAVING PROGRESS ON THIS CULLING METHOD INCASE IT ENDS UP BEING FASTER
       instance_deactivate_all(true);
        
        instance_activate_object(CONTROL);
        instance_activate_object(hudControl);
        instance_activate_object(obj_player);
        instance_activate_object(obj_pie);
        instance_activate_object(EFFECT);
        instance_activate_object(BULLET);
        instance_activate_object(obj_projectile);
        instance_activate_object(ENEMY_PROJ);*/
        
            
        //-Activate everything inside the camera view.
        //NOTE: outerBoundary for activation and deactivation must be synched when changing one of these values. OTHERWISE YOU MIGHT FUCK IT UP FOR A FEW UPDATES :)
        var outerBoundary = 16*16; //-"offscreen" boundary distance from view.
        var enemyBoundary = 5*16; //-tiles enemies are allowed to have active.
        
        //NOTE: width and height arguments require two times the outerBoundaries to make up for the origin point's outerboundary offset.
        instance_activate_region(view_xview[0]-outerBoundary,view_yview[0]-outerBoundary,view_wview[0]+outerBoundary*2,view_hview[0]+outerBoundary*2,true);
        
        //Keep saplings active.
        if instance_exists(obj_sapling)
        {  instance_activate_object(obj_sapling); }
        
        //-Deactivate offscreen objects.
        if instance_exists(obj_itemDrop) then with obj_itemDrop scr_deactivateOffscreen(id);
        if instance_exists(TILE) then with TILE if object_index != obj_pie { scr_deactivateOffscreen(id); alarm[2] = 1; }
        if instance_exists(INTERACT) then with INTERACT scr_deactivateOffscreen(id);
        if instance_exists(NOCOL) then with NOCOL if object_get_parent(object_index) != PLR_NOCOL &amp;&amp; object_index != GREM_BLOCK then scr_deactivateOffscreen(id);
        
        //-Update player buffer
        plr_xBuffer = round(playerX);
        plr_yBuffer = round(playerY);
        
        //-Activate offscreen tiles for needed enemies.
        if array_length_1d(enemyActiveList) &gt; 0
        {
            for (i=0;i&lt;array_length_1d(enemyActiveList);i++)
            {
                with enemyActiveList[i]
                {
                 instance_activate_region(x-enemyBoundary,y-enemyBoundary,x+enemyBoundary,y+enemyBoundary,true);
                }
            }
        }
    }
}

//-----------Light up underground tiles----------------
//Updates every tile.
if playerY &gt; stoneLayer-16*4 &amp;&amp; (player_distance_amt_x &gt; 15 || player_distance_amt_y &gt; 15)
{
    if instance_exists(TILE)
    {
        var daylight_offset = world_Time-(world_TimeMax*0.4);
    
        with TILE
        {
            var dist = point_distance(x,y,playerX,playerY);
            if dist &gt; (playerLight)+16*4 then continue; //Skip tiles that are far away.
        
            if light_level &lt; 255 //Only change the light of tiles that aren't completely bright
            {
                var light_dist = floor(255+(playerLight)-dist*4);
                
                if dist &lt; (playerLight)+32
                { light_level = 255;}
                else if light_dist &lt;= 255 &amp;&amp; light_dist &gt; 0  { light_level = light_dist; }
                else light_level = 0;
               
                light_color = make_colour_hsv(160,max(light_saturation+clamp(daylight_offset/20-3*65,0,max_saturation),max_saturation-max_saturation*interm),light_level); //Increase saturation for cool 'nightime' effect.
            }
        }
    }
    
    if instance_exists(obj_nullLight)
    {
        with obj_nullLight
        {   
            if insideView(x,y) == false then continue;
        
            if light_level &lt; 255
            {
                var dist = point_distance(x,y,playerX,playerY);
                var light_dist = floor(255+(playerLight)-dist*3);
                
                if dist &lt; (playerLight)+32
                { instance_destroy(); }
                else if light_dist &lt;= 255 &amp;&amp; light_dist &gt; 0  { light_level = light_dist; }
                else light_level = 0;
            }
        }
    }
}


//------------- Proliferate every tick ---------------------------
if (heal_Time &gt;= room_speed)
{
    //Tile regeneration
    if interm == true
    {
        if instance_exists(PLRTILE) then with PLRTILE event_user(15);
        if instance_exists(PLR_NOCOL) then with PLR_NOCOL event_user(15);
        with obj_pie event_user(1);
    }
    
    //-Energy &amp; health regeneration-
    if obj_player.hp != obj_player.maxHp &amp;&amp; obj_player.dead == false 
    {
        with obj_player { hp += 1; if hp &gt;= maxHp then hp = maxHp; }
    }
    
    //energy = approach(energy,energyMax,energyRegenRate+(interm*3));
    
    heal_Time = 0;
}

//------------ World Time -------------------
// multiplied by 3 into 3 minutes.

if world_Time &gt;= world_TimeMax //3 minutes
{
    world_Time = 0;
    scr_raidControl(nextRaid,0,0,0,0); //Preset raid
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///D/N Cycle Alpha

var aMax = 0.6;

if interm == true
{
    if dayTransition == true
    {
        if dayAlpha &gt; 0 { dayAlpha -= 0.01; } else dayTransition = false;
    }
    //dayAlpha = equation to get the darkness of the day until til night
    else
    {
        var daylight_offset = world_TimeMax*0.7; //70% of world_TimeMax for use in offsetting the day/night cycle.
        dayAlpha = (world_Time-daylight_offset)/(world_TimeMax-daylight_offset);
    }
    
    dayAlpha = clamp(dayAlpha,0,aMax);
} 
else if interm == false &amp;&amp; gameOver == false
{
    //Makes the alpha drain a little faster during the day transition if set to 0.6;
    dayAlpha = aMax;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CONSTRUCT THE WAVE

//Locals
var difficulty = scr_getDifficulty();
var build_target = waveScale(1,2,1,6)+floor(difficulty/4); //Gremlin variety
var build_index = 0;

//Initialize gremlin lists.
normalGremlins = array_create(0);
specialGremlins = array_create(0);

normalGremlins[0] = obj_gremlin;
specialGremlins[0] = noone;

normal_array_size = array_length_1d(normalGremlins);
special_array_size = array_length_1d(specialGremlins);


//Add normal gremlins to the list as the wave number increases.
switch special_raidID
{
    case "SR_Shadow":
    {
        specialChance = 1;
        normalGremlins[0] = obj_shadowGremlin;
        specialGremlins[0] = obj_shadowGremlin;
    }
    break;
    
    default:
    {    
        //Build'a wave!
        var last_ran = ds_list_create();
        var list_size = 5; //The size of the list of enemies we can choose from.
        var time = 0;
        
        while build_index &lt; build_target
        {    
            time += 1;
        
            //Encourage diversity!
            var ran = irandom(list_size);
            
            normal_array_size = array_length_1d(normalGremlins);
            special_array_size = array_length_1d(specialGremlins);
        
            //Add Gremlins to the list as the difficulty number increases.
            if build_index &lt;= 3
            {
                //Ensure that we select new creatures.
                if ds_list_find_index(last_ran,ran) != -1 { continue; }
            
                //Reset possible random numbers for the next set of mobs.
                if build_index == 3 
                { 
                    ds_list_destroy(last_ran);
                    last_ran = ds_list_create(); 
                }
            
                switch ran
                {
                    case 0: normalGremlins[normal_array_size] = obj_gremlin; break;
                    case 1: if difficulty &gt;= 5 { normalGremlins[normal_array_size] = obj_drillin; } break;
                    case 2: if difficulty &gt;= 3 { normalGremlins[normal_array_size] = obj_shadowGremlin; } break;
                    case 3: if difficulty &gt;= 10 { normalGremlins[normal_array_size] = obj_grassGremlin;} break;
                    case 4: if difficulty &gt;= 15 { specialGremlins[special_array_size] = obj_stoneGremlin;} break;
                }
            }
            //Add region specific enemies if build_target is greater than 4.
            else
            {
            
                switch region
                {
                    case "GRASSLANDS":
                    {
                        switch ran
                        {
                            case 0: if difficulty &gt;= 15 { specialGremlins[special_array_size] = obj_hornedHapp; } break;
                            default: if difficulty &gt;= 12 { normalGremlins[normal_array_size] = obj_sweetWorm; }
                        }
                    }
                    break;
                    
                    case "COVE":
                    {
                        switch ran
                        {
                            case 0: if difficulty &gt;= 16 { normalGremlins[normal_array_size] = obj_mackerel; }  break;
                            case 1: if difficulty &gt;= 14 { normalGremlins[normal_array_size] = obj_sandMenace; } break;
                            default: if difficulty &gt; 12 { specialGremlins[special_array_size] = obj_crab; }
                        }
                    }
                    break;
                }
            }

            //Only increase the build_index number if a gremlin was successfully added to a list.
            if normal_array_size != array_length_1d(normalGremlins) || special_array_size != array_length_1d(specialGremlins)
            { 
                ds_list_add(last_ran,ran);
                build_index += 1;;
            }
            else if time &gt; 20
            {
                build_index = build_target;
            }
        }
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Event: RAID_PROGRESSED
print('Raid Progressed');

//Increase progress meter
if raidProgress &lt;= maxRaidProgress
{
    if raidBoss == false { raidProgress += 1 }
    else if raidProgress &gt;= 99 then raidProgress = 99;
}



//-------RAID DEFEATED EVENT---------

//Check for completion
if raidProgress &gt;= maxRaidProgress
{
    print('Raid Complete');
    scr_raidControl("INTERM",0,0,0,0);
    
    //Grow trees
    if instance_exists(obj_sapling)
    { 
        with obj_sapling
        {
            var r = irandom(10);
            if r &lt;= 7
            {
                scr_treeCreate(x,y);
                itemDrop = false;
                instance_destroy();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="66">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if dev == true then scr_raidControl(nextRaid,0,0,0,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
