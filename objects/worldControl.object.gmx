<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>99</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize world variables
globalvar grav,maxGrav,loadStep,wave,interm,enemyActiveList,RAIDBOUND_Upper,RAIDBOUND_Lower,raidProgress,maxRaidProgress,stoneLayer,specialRaid,nextRaid,world_Time,energy,difficulty;
grav = 0.350;
maxGrav = 5;
loadStep = 0; //Load the world.
wave = 0; //Wave number
interm = true; //intermission boolean
enemyActiveList[0] = noone; //List of enemies that require chunking.
raidProgress = 0; //How many more gremlins need to die before the raid is complete.
maxRaidProgress = 100; //Raid goal.
stoneLayer = (room_height/2-48)+(10*16); //Around the layer of stone
energy = 0;

//local variable that needs to be set before scr_raidControl :)
region_shift = false; //Whether or not to shift the region next intermission.
special_raidID = "";


//Local variables
world_Time = 0;
heal_Time = 10; //Heal something (defense) every interval.
playerTiles = 0;
view_zoom_buffer = 0; //Remember the last value of the zoom.
maxGrem = 5; //Maximum gremlins in the world.
spawnRate = 1; //How many times a second to check for and spawn a thing.
spawnChance = 0; //The chance that the thing will spawn out of 100.
raidBoss = false; //No raid boss.
raidBossID = noone; //The instance ID of the boss.
nextRaid = "RAID"; //The next raid's type.
specialRaid = false; //Bool telling whether or not a special raid is in progress.
special_raidID = noone; //The ID of the raid
world_TimeMax = room_speed*(3*60);
dayTransition = false; //Whether or not to transition into day;
dayAlpha = 0;
deactivation_enabled = true;
shift_destination = "";

if room == rm_zero 
{
    scr_loadWorld(noone);
    scr_raidControl("INTERM",0,0,0,0); //Preset setting, other arguments not required.
    plr_xBuffer = 0;
    plr_yBuffer = 0;
    alarm[0] = 2;
    alarm[1] = 120;
}
else if room == rm_tutorial
{
    scr_loadWorld("TUTORIAL");
    scr_raidControl(0,0,0,0,0); //Tutorial stuff
    alarm[0] = 1;
    alarm[1] = 120;
    plr_xBuffer = 0;
    plr_yBuffer = 0;
    with worldControl { event_user(1); }
}

//global.light_surface = surface_create(display_get_width(),display_get_height());

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn gremlins

var _viewX = view_xview[0];
var _viewW = view_wview[0]+_viewX; //wview is a constant denoting the size of the view.
var _viewY = view_yview[0];
var _viewH = view_hview[0]+_viewY;


if instance_number(ENEMY) &lt; maxGrem &amp;&amp; irandom(100) &lt;= spawnChance
{
    var outer_x_range = 2*16; //Defines how many tiles outside the xview the enemy can spawn.
    if interm == false then outer_x_range = 5;
    //var outer_y_range = irandom_range(1,5)*16; //Defines how many tiles outside the yview the enemy can spawn.
    
    var xx = choose(_viewX,_viewW);
    var yy = choose(_viewY,_viewH);
    var xdir = sign(xx-obj_player.x);
    
    //Change xx coordinate
    xx = xx+(xdir*irandom(outer_x_range));
      
    //Center points
    xx = floor(xx/16)*16;
    yy = floor(yy/16)*16;
    
    //Spawn mobs outside flat lands + (or during raids)
    var spawn_at_portal = false;
    
    if (xx &gt;= RAIDBOUND_Lower &amp;&amp; xx &lt;= RAIDBOUND_Upper) || interm == false
    {
        xx = choose(RAIDBOUND_Lower-16,RAIDBOUND_Upper+16); 
        yy = (room_height/2)-(16*4);
        spawn_at_portal = !interm; //if interm == false then spawn_at_portal = true;
    }
    
    //Gremlins spawn on top of stuff
    while position_meeting(xx,yy,OBSTA) yy-=16;
    
    //Spawn gremlin
    var specialChance = 0.3;
    var gremNumber = random(1);
    
    //-Check whether or not the enemy will spawn inside the view.
    if !point_in_rectangle(xx,yy,_viewX,_viewY,_viewW,_viewH)
    {
        //--SpawnGremlins directly ontop of a tile from the sky
        while (!position_meeting(xx,yy+16,TILE_ALL) &amp;&amp; !position_meeting(xx,yy+16,GREM_BLOCK)) { yy+=16; if yy &gt; room_height then break; }
        
        new_raidGremlin(xx,yy,gremNumber,specialChance,special_raidID);
        
        //Special mob spawns.
            //-Sphere Pylon
        if interm == true
        {
            if irandom(50) &gt;= 49 &amp;&amp; nextRaid != "SPHERE"
            {
                instance_create(xx,yy,obj_spherePylon);
            }
        }
    } else if spawn_at_portal == true { new_raidGremlin(xx,yy,gremNumber,specialChance,special_raidID); }
    
    //Clear active mob roster
    if array_length_1d(enemyActiveList) &gt; 3 { enemyActiveList = 0; }
    
    
} 
else if instance_number(ENEMY) &gt;= maxGrem
{
    //Despawn an offview gremlin.
    for (i=0;i&lt;instance_number(ENEMY);i++)
    {
        var grem = instance_find(ENEMY,i);
        var gx = grem.x;
        var gy = grem.y;
        
        //Don't despawn the bosses
        if grem == raidBossID || grem.canDespawn == false then break;
        
        //Don't despawn things inside the Flatlands and above the stone layer
        if !(gx &gt;= RAIDBOUND_Lower &amp;&amp; gx &lt;= RAIDBOUND_Upper) &amp;&amp; (gy &gt;= stoneLayer)
        {
            //Check whether or not the gremlin is visible.
            if !point_in_rectangle(gx,gy,_viewX,_viewY,_viewW,_viewH)
            {
                with grem { dropItem = false; instance_destroy(); }
                break;
            }
        }
    }
}

alarm[1] = room_speed/spawnRate;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Deactivation/Chunking and World Time
alarm[0] = 1;
//if deactivation_enabled == false then exit;

//- time control
if interm == true 
{ world_Time += 1; }

heal_Time += 1;

//- init logic
var playerX = obj_player.x;
var playerY = obj_player.y;
var view_zoom = camera.view_zoom;
var playerLight = obj_player.playerLight;

var player_distance_amt_x = abs(playerX-plr_xBuffer);
var player_distance_amt_y = abs(playerY-plr_yBuffer);

//----Deactivation---------
if view_zoom != view_zoom_buffer
{
    //Update view_zoom
    view_zoom = view_zoom_buffer;
    
    //-Deactivation and Reactivation updates every eight tiles.
    if (player_distance_amt_x &gt; 16*2 || player_distance_amt_y &gt; 16*2)
    {
            
        //-Activate everything inside the camera view.
        var outerBoundary = 10*16; //-"offscreen" boundary distance from view.
        var enemyBoundary = 5*16; //-tiles enemies are allowed to have active.
        instance_activate_region(view_xview[0]-outerBoundary,view_yview[0]-outerBoundary,450+2*(outerBoundary),450+2*(outerBoundary),true);
        
        //Keep saplings active.
        if instance_exists(obj_sapling)
        {   instance_activate_object(obj_sapling); }
        
        //-Deactivate offscreen objects.
        if instance_exists(obj_itemDrop) then with obj_itemDrop scr_deactivateOffscreen(id);
        if instance_exists(TILE) then with TILE if object_index != obj_pie { scr_deactivateOffscreen(id); }
        if instance_exists(INTERACT) then with INTERACT scr_deactivateOffscreen(id);
        if instance_exists(NOCOL) then with NOCOL if object_get_parent(object_index) != PLR_NOCOL then scr_deactivateOffscreen(id);
        
        //-Update player buffer
        plr_xBuffer = round(playerX);
        plr_yBuffer = round(playerY);
        
        //-Activate offscreen tiles for needed enemies.
        if array_length_1d(enemyActiveList) &gt; 0
        {
            for (i=0;i&lt;array_length_1d(enemyActiveList);i++)
            {
                with enemyActiveList[i]
                {
                 instance_activate_region(x-enemyBoundary,y-enemyBoundary,x+enemyBoundary,y+enemyBoundary,true);
                }
            }
        }
    }
}

//-----------Light up underground tiles----------------
//Updates every tile.
if playerY &gt; stoneLayer-48 &amp;&amp; (player_distance_amt_x &gt; 15 || player_distance_amt_y &gt; 15)
{
    if instance_exists(TILE)
    {
        with TILE
        {
            if insideView(x,y) == false then continue;
        
            if light_level &lt; 255
            {
                var dist = point_distance(x,y,playerX,playerY);
                var light_dist = floor(255+(playerLight)-dist*3);
                
                if dist &lt; (playerLight)+32
                { light_level = 255;}
                else if light_dist &lt;= 255 &amp;&amp; light_dist &gt; 0  { light_level = light_dist; }
                else light_level = 0;
            }
        }
    }
    
    if instance_exists(obj_nullLight)
    {
        with obj_nullLight
        {   
            if insideView(x,y) == false then continue;
        
            if light_level &lt; 255
            {
                var dist = point_distance(x,y,playerX,playerY);
                var light_dist = floor(255+(playerLight)-dist*3);
                
                if dist &lt; (playerLight)+32
                { instance_destroy(); }
                else if light_dist &lt;= 255 &amp;&amp; light_dist &gt; 0  { light_level = light_dist; }
                else light_level = 0;
            }
        }
    }
}


//------------- Proliferate every tick ---------------------------
if heal_Time &gt;= (room_speed-max(tileRegenRate,30))
{
    //Tile regeneration
    if interm == true
    {
        if instance_exists(PLRTILE) then with PLRTILE event_user(15);
        if instance_exists(PLR_NOCOL) then with PLR_NOCOL event_user(15);
        with obj_pie event_user(1);
    }
    
    //-Energy &amp; health regeneration-
    if obj_player.hp != obj_player.maxHp &amp;&amp; obj_player.dead == false with obj_player { hp += 1; if hp &gt;= maxHp then hp = maxHp; }
    energy = approach(energy,energyMax,energyRegenRate);
    
    heal_Time = 0;
}

//------------ World Time -------------------
// multiplied by 3 into 3 minutes.

if world_Time &gt;= world_TimeMax //3 minutes
{
    world_Time = 0;
    scr_raidControl(nextRaid,0,0,0,0); //Preset raid
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///D/N Cycle Alpha

var aMax = 0.6;

if interm == true
{
    //Alpha = equation to get the darkness of the day until til night
    if dayTransition == true
    {
        if dayAlpha &gt; 0 { dayAlpha -= 0.01; } else dayTransition = false;
    }
    else dayAlpha = ((world_Time/world_TimeMax));
    
    dayAlpha = clamp(dayAlpha,0,aMax);
} 
else if interm == false 
{
    dayAlpha = aMax;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CONSTRUCT THE WAVE

//Locals
var difficulty = wave + (kingDied_1*5);
var build_target = waveScale(1,4,2,6)+floor(difficulty/wave); //Gremlin variety
var build_index = 0;

//Initialize gremlin lists.
normalGremlins = array_create(0);
specialGremlins = array_create(0);

normalGremlins[0] = obj_gremlin;
specialGremlins[0] = noone;

normal_array_size = array_length_1d(normalGremlins);
special_array_size = array_length_1d(specialGremlins);


//Add normal gremlins to the list as the wave number increases.
switch special_raidID
{
    case "SR_Shadow":
    {
        specialChance = 1;
        specialGremlins[0] = obj_shadowGremlin;
    }
    break;
    
    default:
    {    
        //Build'a wave!
        var last_ran = 0;
        var list_size = 5; //The size of the list of enemies we can choose from.
        
        while build_index &lt; build_target
        {    
            //Encourage diversity!
            var ran = irandom(list_size);
            
            if ran == last_ran
            {
                //Note: irandom(last_ran) will naturally make enemies higher on the list less likely to spawn.
                ran = irandom(last_ran);
            }
            
            normal_array_size = array_length_1d(normalGremlins);
            special_array_size = array_length_1d(specialGremlins);
        
            //Add Gremlins to the list as the difficulty number increases.
            switch ran
            {
                case 0: normalGremlins[normal_array_size] = obj_gremlin; break;
                case 1: if difficulty &gt;= 4 { normalGremlins[normal_array_size] = obj_drillin; } break;
                case 2: if difficulty &gt;= 2 { normalGremlins[normal_array_size] = obj_shadowGremlin; } break;
                case 3: if difficulty &gt;= 10 { normalGremlins[normal_array_size] = obj_grassGremlin;} break;
                case 4: if difficulty &gt;= 12 { normalGremlins[normal_array_size] = obj_stoneGremlin;} break;
            }
            
            //Add a region specific enemy!
            if build_index &gt; 4
            {
                switch region
                {
                    case "GRASSLANDS":
                    {
                        switch ran
                        {
                            default: { if difficulty &gt; 10 { normalGremlins[normal_array_size] = obj_sweetWorm; } } break;
                            case 0: { if difficulty &gt; 20 { specialGremlins[special_array_size] = obj_hornedHapp; } } break;
                        }
                    }
                    break;
                    
                    case "COVE":
                    {
                        //Nothing to see here folks!
                    }
                    break;
                }
            }

            //Only increase the build_index number if a gremlin was successfully added to a list.
            if normal_array_size != array_length_1d(normalGremlins) || special_array_size != array_length_1d(specialGremlins)
            { 
                build_index += 1;
            }
        }
    }
}

//Hud Control information sprites!
hudControl.enemySprites = ds_list_create();

var enemySprites = hudControl.enemySprites;
    
//- Populate the array with normal gremlins!
for (_a=0;_a&lt;normal_array_size;_a++)
{
    var _sprite = object_get_sprite(normalGremlins[_a]);
    
    if sprite_exists(_sprite)
    {
        //If the enemy sprite is not apart of our list, then add it.
        if ds_list_find_index(enemySprites,_sprite) == -1
        {
            ds_list_add(enemySprites,_sprite);
        }
    }
}

//- Populate the array with special gremlins!
for (_a=0;_a&lt;special_array_size;_a++)
{
    var _sprite = object_get_sprite(specialGremlins[_a]);
    
    if sprite_exists(_sprite)
    {
        //If the enemy sprite is not apart of our list, then add it.
        if ds_list_find_index(enemySprites,_sprite) == -1
        {
            ds_list_add(enemySprites,_sprite);
        }
    }
}

ds_list_copy(hudControl.enemySprites,enemySprites);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Event: RAID_PROGRESSED
print('Raid Progressed');

//Increase progress meter
if raidProgress &lt;= maxRaidProgress
{
    if raidBoss == false { raidProgress += 1 }
    else if raidProgress &gt;= 99 then raidProgress = 99;
}



//-------RAID DEFEATED EVENT---------

//Check for completion
if raidProgress &gt;= maxRaidProgress
{
    print('Raid Complete');
    scr_raidControl("INTERM",0,0,0,0);
    
    //Grow trees
    if instance_exists(obj_sapling)
    { 
        with obj_sapling
        {
            var r = irandom(10);
            if r &lt;= 7
            {
                scr_treeCreate(x,y);
                instance_destroy();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="66">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if dev == true then scr_raidControl(nextRaid,0,0,0,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
